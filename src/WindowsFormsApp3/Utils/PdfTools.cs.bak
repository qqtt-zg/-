using System;
using System.IO;
using Spire.Pdf;
using Spire.Pdf.Graphics;
using Spire.Pdf.Graphics.Layer;
using System.Drawing;
using iText.Kernel.Pdf;
using iText.Kernel.Geom;
using iText.Kernel.Pdf.Canvas;
using iText.Kernel.Pdf.Layer;
using iText.Kernel.Colors;
using SystemPath = System.IO.Path;
using System.Linq;
using WindowsFormsApp3.Models;
using WindowsFormsApp3.Services;
using System.Collections.Generic;

namespace WindowsFormsApp3.Utils
{
    /// <summary>
    /// PDF工具类，封装PDF操作相关功能，使用Spire.Pdf和iText7库实现
    /// 注意：PDF尺寸相关功能已迁移至IText7PdfTools，此类仅保留非尺寸相关的功能
    /// 已完成PDFsharp到iText7的迁移，页面框设置功能现在使用iText7实现
    /// </summary>
    public static class PdfTools
    {
  
        /// <summary>
        /// 检查PDF文件中是否存在指定的图层
        /// </summary>
        /// <param name="filePath">PDF文件路径</param>
        /// <param name="layerNames">要检查的图层名称列表</param>
        /// <returns>如果所有指定图层都存在则返回true，否则返回false</returns>
        public static bool CheckPdfLayersExist(string filePath, params string[] layerNames)
        {
            try
            {
                // 检查文件是否存在
                if (!File.Exists(filePath))
                {
                    return false;
                }

                // 检查文件扩展名是否为PDF
                if (!SystemPath.GetExtension(filePath).Equals(".pdf", StringComparison.OrdinalIgnoreCase))
                {
                    return false;
                }

                using (Spire.Pdf.PdfDocument document = new Spire.Pdf.PdfDocument())
                {
                    document.LoadFromFile(filePath);

                    // 检查所有指定的图层是否存在
                    foreach (string layerName in layerNames)
                        {
                            bool layerExists = false;
                            foreach (Spire.Pdf.Graphics.Layer.PdfLayer layer in document.Layers)
                            {
                                if (string.Equals(layer.Name, layerName, StringComparison.OrdinalIgnoreCase))
                                {
                                    layerExists = true;
                                    break;
                                }
                            }

                            // 如果任一指定的图层不存在，则返回false
                            if (!layerExists)
                            {
                                return false;
                            }
                        }

                    return true; // 所有指定的图层都存在
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("检查PDF图层失败: " + ex.Message);
                return false;
            }
        }

  
        /// <summary>
        /// 为PDF文件添加名为"Dots_AddCounter"的图层（新的枚举版本）
        /// </summary>
        /// <param name="filePath">PDF文件路径</param>
        /// <param name="finalDimensions">最终尺寸，格式为"宽度x高度"（毫米）</param>
        /// <param name="shapeType">形状类型</param>
        /// <param name="roundRadius">圆角半径（仅用于圆角矩形）</param>
        /// <returns>是否成功添加图层</returns>
        public static bool AddDotsAddCounterLayer(string filePath, string finalDimensions, ShapeType shapeType, double roundRadius = 0)
        {
            LogHelper.Debug($"AddDotsAddCounterLayer调用（枚举版本），参数: filePath={filePath}, shapeType={shapeType}, roundRadius={roundRadius}");

            // 检查文件是否存在
            if (!File.Exists(filePath))
            {
                LogHelper.Debug("文件不存在: " + filePath);
                return false;
            }

            // 检查文件扩展名是否为PDF
            if (!SystemPath.GetExtension(filePath).Equals(".pdf", StringComparison.OrdinalIgnoreCase))
            {
                LogHelper.Debug("文件不是PDF格式: " + filePath);
                return false;
            }

            // 异形处理直接调用专用方法
            if (shapeType == ShapeType.Special)
            {
                LogHelper.Debug("检测到异形，调用ProcessSpecialShapePdf");
                return ProcessSpecialShapePdf(filePath);
            }

            string tempFilePath = null;
            try
            {
                // 首先使用PDFsharp设置所有页面框为与CropBox一致
                LogHelper.Debug("首先使用PDFsharp设置页面框");
                bool setBoxesResult = SetAllPageBoxesToCropBox(filePath);
                if (!setBoxesResult)
                {
                    LogHelper.Debug("设置页面框失败");
                    return false;
                }

                // 创建临时文件路径
                string cacheFolder = SystemPath.Combine(SystemPath.GetTempPath(), "PDFToolCache");
                Directory.CreateDirectory(cacheFolder);
                tempFilePath = SystemPath.Combine(cacheFolder, $"temp_{Guid.NewGuid()}.pdf");

                // 复制原始文件到临时文件
                File.Copy(filePath, tempFilePath, true);

                using (Spire.Pdf.PdfDocument document = new Spire.Pdf.PdfDocument())
                {
                    document.LoadFromFile(tempFilePath);

                    // 获取或创建图层 - 实现真正的获取或创建逻辑
                    Spire.Pdf.Graphics.Layer.PdfLayer layer = GetOrCreateLayer(document, "Dots_AddCounter");
                    // 获取或创建Dots_L_B_出血线图层
                    Spire.Pdf.Graphics.Layer.PdfLayer bleedLayer = GetOrCreateLayer(document, "Dots_L_B_出血线");

                    // 解析finalDimensions参数
                    float rectWidth = 0;
                    float rectHeight = 0;
                    if (!string.IsNullOrEmpty(finalDimensions))
                    {
                        LogHelper.Debug("解析finalDimensions: " + finalDimensions);
                        string[] dimensions = finalDimensions.Split('x');
                        if (dimensions.Length == 2)
                        {
                            // 提取宽度（去掉任何非数字字符）
                            string widthStr = ExtractNumericValue(dimensions[0]);

                            // 提取高度（去掉任何非数字字符和后续的形状代号）
                            string heightStr = ExtractNumericValue(dimensions[1]);

                            LogHelper.Debug("提取的尺寸: 宽=" + widthStr + ", 高=" + heightStr);

                            // 转换毫米到点（1mm≈2.83465点）
                            if (float.TryParse(widthStr, out float widthMm) && float.TryParse(heightStr, out float heightMm))
                            {
                                float calculatedWidth = (float)(widthMm * 2.83465);
                                float calculatedHeight = (float)(heightMm * 2.83465);

                                // 获取页面方向信息（通过页面宽高比判断）- 使用iText7
                                bool isPageLandscape = false;
                                try
                                {
                                    using (iText.Kernel.Pdf.PdfReader reader = new iText.Kernel.Pdf.PdfReader(filePath))
                                    using (iText.Kernel.Pdf.PdfDocument pdfDoc = new iText.Kernel.Pdf.PdfDocument(reader))
                                    {
                                        if (pdfDoc.GetNumberOfPages() > 0)
                                        {
                                            iText.Kernel.Pdf.PdfPage pdfPage = pdfDoc.GetPage(1);
                                            iText.Kernel.Geom.Rectangle pageSize = pdfPage.GetCropBox() ?? pdfPage.GetMediaBox();
                                            if (pageSize != null)
                                            {
                                                isPageLandscape = pageSize.GetWidth() > pageSize.GetHeight();
                                                LogHelper.Debug("iText7页面方向检测成功: " + (isPageLandscape ? "横向" : "纵向"));
                                            }
                                        }
                                    }
                                }
                                catch (Exception ex)
                                {
                                    LogHelper.Debug("iText7页面方向检测失败: " + ex.Message + "，使用默认方向");
                                }

                                // 检查计算出的尺寸与页面方向是否匹配
                                bool isCalculatedLandscape = calculatedWidth > calculatedHeight;

                                // 如果页面方向和计算出的尺寸方向不一致，则交换宽度和高度
                                if (isPageLandscape != isCalculatedLandscape)
                                {
                                    rectWidth = calculatedHeight;
                                    rectHeight = calculatedWidth;
                                    LogHelper.Debug("检测到方向不匹配，交换宽度和高度: 宽=" + rectWidth + ", 高=" + rectHeight);
                                }
                                else
                                {
                                    rectWidth = calculatedWidth;
                                    rectHeight = calculatedHeight;
                                    LogHelper.Debug("转换后的尺寸(点): 宽=" + rectWidth + ", 高=" + rectHeight);
                                }
                            }
                        }
                    }

                    // 为所有页面添加图层内容
                    for (int i = 0; i < document.Pages.Count; i++)
                    {
                        Spire.Pdf.PdfPageBase page = document.Pages[i];

                        // 计算实际尺寸
                        float actualRectWidth = rectWidth;
                        float actualRectHeight = rectHeight;

                        if (actualRectWidth <= 0 || actualRectHeight <= 0)
                        {
                            LogHelper.Debug("未提供有效的finalDimensions，使用默认尺寸");
                            float minSize = 50f;
                            float maxWidthRatio = 0.8f;
                            float maxHeightRatio = 0.8f;

                            actualRectWidth = Math.Max(minSize, page.Size.Width * maxWidthRatio);
                            actualRectHeight = Math.Max(minSize, page.Size.Height * maxHeightRatio);

                            LogHelper.Debug("使用默认尺寸(点): 宽=" + actualRectWidth + ", 高=" + actualRectHeight);
                        }

                        // 计算居中位置
                        float rectX = (page.Size.Width - actualRectWidth) / 2;
                        float rectY = (page.Size.Height - actualRectHeight) / 2;

                        LogHelper.Debug($"第{i+1}页形状绘制信息: 位置=({rectX}, {rectY}), 尺寸=({actualRectWidth}x{actualRectHeight}), 形状类型={shapeType}");

                        // 创建红色描边的笔，粗细为0.01
                        Spire.Pdf.Graphics.PdfPen redPen = new Spire.Pdf.Graphics.PdfPen(System.Drawing.Color.Red, 0.01f);

                        // 获取图层的图形对象
                        Spire.Pdf.Graphics.PdfCanvas layerCanvas = layer.CreateGraphics(page.Canvas);

                        // 根据shapeType绘制不同的形状
                        switch (shapeType)
                        {
                            case ShapeType.Circle:
                                LogHelper.Debug("绘制圆形");
                                layerCanvas.DrawEllipse(redPen, rectX, rectY, actualRectWidth, actualRectHeight);
                                break;

                            case ShapeType.RoundRect:
                                LogHelper.Debug($"绘制圆角矩形，半径={roundRadius}毫米");
                                float cornerRadiusPt = (float)(roundRadius * 2.83465); // 转换毫米到点

                                // 使用PdfPath手动创建圆角矩形
                                Spire.Pdf.Graphics.PdfPath path = new Spire.Pdf.Graphics.PdfPath();

                                // 确保圆角半径不会太大
                                float radiusPt = Math.Min(cornerRadiusPt, Math.Min(actualRectWidth, actualRectHeight) / 2);

                                LogHelper.Debug($"圆角半径计算: 原始={cornerRadiusPt}点, 限制到={radiusPt}点");

                                // 绘制圆角矩形的各个角和边
                                path.AddArc(rectX + actualRectWidth - 2 * radiusPt, rectY, 2 * radiusPt, 2 * radiusPt, 270, 90);
                                path.AddLine(rectX + actualRectWidth, rectY + radiusPt, rectX + actualRectWidth, rectY + actualRectHeight - radiusPt);
                                path.AddArc(rectX + actualRectWidth - 2 * radiusPt, rectY + actualRectHeight - 2 * radiusPt, 2 * radiusPt, 2 * radiusPt, 0, 90);
                                path.AddLine(rectX + actualRectWidth - radiusPt, rectY + actualRectHeight, rectX + radiusPt, rectY + actualRectHeight);
                                path.AddArc(rectX, rectY + actualRectHeight - 2 * radiusPt, 2 * radiusPt, 2 * radiusPt, 90, 90);
                                path.AddLine(rectX, rectY + actualRectHeight - radiusPt, rectX, rectY + radiusPt);
                                path.AddArc(rectX, rectY, 2 * radiusPt, 2 * radiusPt, 180, 90);
                                path.AddLine(rectX + radiusPt, rectY, rectX + actualRectWidth - radiusPt, rectY);

                                path.CloseAllFigures();
                                layerCanvas.DrawPath(redPen, path);
                                break;

                            case ShapeType.RightAngle:
                            default:
                                LogHelper.Debug("绘制直角矩形");
                                layerCanvas.DrawRectangle(redPen, rectX, rectY, actualRectWidth, actualRectHeight);
                                break;
                        }

                        // 在Dots_L_B_出血线图层上绘制绿色居中矩形
                        float bleedRectX = 0;
                        float bleedRectY = 0;
                        float bleedRectWidth = page.Size.Width;
                        float bleedRectHeight = page.Size.Height;

                        Spire.Pdf.Graphics.PdfPen greenPen = new Spire.Pdf.Graphics.PdfPen(System.Drawing.Color.Green, 0.01f);
                        Spire.Pdf.Graphics.PdfCanvas bleedLayerCanvas = bleedLayer.CreateGraphics(page.Canvas);
                        bleedLayerCanvas.DrawRectangle(greenPen, bleedRectX, bleedRectY, bleedRectWidth, bleedRectHeight);
                    }

                    // 保存修改后的PDF文件
                    document.SaveToFile(tempFilePath);
                    document.Close();

                    // 确保文件完全释放后再进行文件操作
                    EnsureFileReleased(filePath);

                    // 验证临时文件完整性
                    if (!File.Exists(tempFilePath) || new FileInfo(tempFilePath).Length == 0)
                    {
                        LogHelper.Debug("临时文件生成失败或为空: " + tempFilePath);
                        return false;
                    }

                    // 删除原始文件并将临时文件重命名为原始文件名
                    if (File.Exists(filePath))
                    {
                        // 直接删除原文件，不创建备份（用户只需要导出路径有一个结果文件）
                        try
                        {
                            File.Delete(filePath);
                            LogHelper.Debug("成功删除原文件: " + filePath);
                        }
                        catch (Exception deleteEx)
                        {
                            LogHelper.Debug("删除原文件失败: " + deleteEx.Message);
                            // 如果删除失败，直接抛出异常，不创建备份
                            throw;
                        }
                    }

                    // 确保临时文件存在且完整
                    if (File.Exists(tempFilePath) && new FileInfo(tempFilePath).Length > 0)
                    {
                        File.Move(tempFilePath, filePath);
                        LogHelper.Debug("成功移动临时文件到目标位置: " + filePath);
                    }
                    else
                    {
                        LogHelper.Debug("临时文件不存在或为空，操作取消: " + tempFilePath);
                        return false;
                    }

                    // 验证最终文件操作成功
                    if (!File.Exists(filePath) || new FileInfo(filePath).Length == 0)
                    {
                        LogHelper.Debug("最终文件操作失败: " + filePath);
                        return false;
                    }

                    LogHelper.Debug("AddDotsAddCounterLayer（枚举版本）完成");
                    return true;
                }
            }
            catch (Exception ex)
            {
                LogHelper.Debug("添加图层失败: " + ex.Message);
                return false;
            }
            finally
            {
                // 确保清理临时文件
                if (tempFilePath != null && File.Exists(tempFilePath))
                {
                    try
                    {
                        File.Delete(tempFilePath);
                    }
                    catch (Exception ex)
                    {
                        LogHelper.Debug("清理临时文件失败: " + ex.Message);
                    }
                }
            }
        }

        /// <summary>
        /// 为PDF文件添加名为"Dots_AddCounter"的图层（兼容旧版本）
        /// </summary>
        /// <param name="filePath">PDF文件路径</param>
        /// <param name="finalDimensions">最终尺寸，格式为"宽度x高度"（毫米）</param>
        /// <param name="cornerRadius">圆角半径，"0"表示直角矩形，"R"表示圆形，其他数值表示圆角矩形</param>
        /// <param name="usePdfLastPage">是否使用PDF最后一页逻辑</param>
        /// <returns>是否成功添加图层</returns>
        [Obsolete("请使用AddDotsAddCounterLayer(string, string, ShapeType, double)方法")]
        public static bool AddDotsAddCounterLayer(string filePath, string finalDimensions, string cornerRadius = "0", bool usePdfLastPage = false)
        {
            // 将旧参数转换为新的枚举类型
            ShapeType shapeType;
            double roundRadius = 0;

            if (usePdfLastPage || string.Equals(cornerRadius, "Y", StringComparison.OrdinalIgnoreCase))
            {
                shapeType = ShapeType.Special;
            }
            else if (string.Equals(cornerRadius, "R", StringComparison.OrdinalIgnoreCase))
            {
                shapeType = ShapeType.Circle;
            }
            else if (double.TryParse(cornerRadius, out double radius) && radius > 0)
            {
                shapeType = ShapeType.RoundRect;
                roundRadius = radius;
            }
            else
            {
                shapeType = ShapeType.RightAngle;
            }

            // 调用新的枚举版本
            return AddDotsAddCounterLayer(filePath, finalDimensions, shapeType, roundRadius);
        }

        /// <summary>
        /// 处理异形PDF文件逻辑（使用iText 7实现）
        /// </summary>
        /// <param name="filePath">PDF文件路径</param>
        /// <returns>是否处理成功</returns>
      /// <summary>
        /// 确保文件完全释放，等待文件句柄关闭
        /// </summary>
        /// <param name="filePath">文件路径</param>
        private static void EnsureFileReleased(string filePath)
        {
            if (!File.Exists(filePath))
                return;

            int maxRetries = 10;
            int retryDelay = 100; // 毫秒

            for (int i = 0; i < maxRetries; i++)
            {
                try
                {
                    // 尝试以独占方式打开文件来检查是否被占用
                    using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.ReadWrite, FileShare.None))
                    {
                        // 如果能够成功打开，说明文件已经释放
                        break;
                    }
                }
                catch (IOException)
                {
                    // 文件仍被占用，等待后重试
                    if (i == maxRetries - 1)
                    {
                        LogHelper.Debug($"文件在{maxRetries}次尝试后仍被占用: {filePath}");
                        throw;
                    }
                    
                    LogHelper.Debug($"文件仍被占用，等待{retryDelay}ms后重试 ({i + 1}/{maxRetries}): {filePath}");
                    System.Threading.Thread.Sleep(retryDelay);
                    retryDelay = Math.Min(retryDelay * 2, 1000); // 指数退避，最大1秒
                }
            }
        }

        /// <summary>
        /// 清理临时文件和备份文件
        /// </summary>
        /// <param name="directory">目录路径</param>
        /// <param name="pattern">文件模式</param>
        private static void CleanupTempFiles(string directory, string pattern)
        {
            try
            {
                if (Directory.Exists(directory))
                {
                    var tempFiles = Directory.GetFiles(directory, pattern);
                    foreach (var tempFile in tempFiles)
                    {
                        try
                        {
                            var fileInfo = new FileInfo(tempFile);
                            // 删除超过1小时的临时文件
                            if (DateTime.Now - fileInfo.CreationTime > TimeSpan.FromHours(1))
                            {
                                File.Delete(tempFile);
                                LogHelper.Debug($"清理过期临时文件: {tempFile}");
                            }
                        }
                        catch (Exception ex)
                        {
                            LogHelper.Debug($"清理临时文件失败 {tempFile}: {ex.Message}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                LogHelper.Debug($"清理临时文件目录失败 {directory}: {ex.Message}");
            }
        }

        public static bool ProcessSpecialShapePdf(string filePath)
        {
            LogHelper.Debug("ProcessSpecialShapePdf调用（iText 7版本），文件路径: " + filePath);
            try
            {
                // 检查文件是否存在
                if (!File.Exists(filePath))
                {
                    LogHelper.Debug("文件不存在: " + filePath);
                    return false;
                }

                // 检查文件扩展名是否为PDF
                if (!SystemPath.GetExtension(filePath).Equals(".pdf", StringComparison.OrdinalIgnoreCase))
                {
                    return false;
                }

                // 首先设置所有页面框为与CropBox一致，这是避免内容被截断的关键步骤
                LogHelper.Debug("首先设置页面框");
                bool setBoxesResult = SetAllPageBoxesToCropBox(filePath);
                if (!setBoxesResult)
                {
                    LogHelper.Debug("设置页面框失败");
                    return false;
                }

                // 创建临时文件路径
                string tempFolder = SystemPath.Combine(SystemPath.GetTempPath(), "PDFToolCache");
                Directory.CreateDirectory(tempFolder);
                string tempFilePath = SystemPath.Combine(tempFolder, SystemPath.GetRandomFileName() + ".pdf");

                iText.Kernel.Pdf.PdfReader reader = null;
                iText.Kernel.Pdf.PdfWriter writer = null;
                iText.Kernel.Pdf.PdfDocument document = null;

                try
                {
                    reader = new iText.Kernel.Pdf.PdfReader(filePath);
                    writer = new iText.Kernel.Pdf.PdfWriter(tempFilePath);
                    document = new iText.Kernel.Pdf.PdfDocument(reader, writer);

                    // 检查文档页数
                    if (document.GetNumberOfPages() < 2)
                    {
                        LogHelper.Debug("文档页数不足2页，无法执行异形处理");
                        return false; // 至少需要2页才能执行异形处理
                    }

                    // 保存原始旋转状态
                    List<int> originalPageRotations = new List<int>();
                    for (int i = 1; i <= document.GetNumberOfPages(); i++)
                    {
                        iText.Kernel.Pdf.PdfPage page = document.GetPage(i);
                        originalPageRotations.Add(page.GetRotation());
                    }

                    // 获取最后一页作为模板
                    int lastPageIndex = document.GetNumberOfPages();
                    iText.Kernel.Pdf.PdfPage lastPage = document.GetPage(lastPageIndex);

                    // 保存最后一页的原始旋转状态
                    int originalLastPageRotation = lastPage.GetRotation();

                    // 临时清除原页面旋转 - 防止旋转导致的内容截断问题
                    lastPage.SetRotation(0); // 重置为0度

                    // 创建图层（使用iText 7的OCG功能）
                    // 创建Dots_AddCounter图层
                    iText.Kernel.Pdf.Layer.PdfLayer addCounterLayer = new iText.Kernel.Pdf.Layer.PdfLayer("Dots_AddCounter", document);
                    // 创建Dots_L_B_出血线图层
                    iText.Kernel.Pdf.Layer.PdfLayer bleedLayer = new iText.Kernel.Pdf.Layer.PdfLayer("Dots_L_B_出血线", document);

                    // 获取最后一页的尺寸
                    iText.Kernel.Geom.Rectangle lastPageSize = lastPage.GetCropBox() ?? lastPage.GetMediaBox();

                    // 为文档的所有页面添加模板内容和出血线
                    for (int i = 1; i <= document.GetNumberOfPages(); i++)
                    {
                        iText.Kernel.Pdf.PdfPage currentPage = document.GetPage(i);

                        // 保存当前页面的原始旋转状态
                        int originalCurrentPageRotation = currentPage.GetRotation();

                        // 临时清除当前页面旋转 - 防止旋转导致的内容截断
                        currentPage.SetRotation(0);

                        // 获取当前页面尺寸
                        iText.Kernel.Geom.Rectangle currentPageSize = currentPage.GetCropBox() ?? currentPage.GetMediaBox();

                        // 计算居中位置 - 确保内容居中显示，避免内容被截断
                        float centerX = (float)((currentPageSize.GetWidth() - lastPageSize.GetWidth()) / 2);
                        float centerY = (float)((currentPageSize.GetHeight() - lastPageSize.GetHeight()) / 2);
                        LogHelper.Debug("第" + i + "页居中位置: X=" + centerX + ", Y=" + centerY);

                        // 1. 在Dots_AddCounter图层上绘制最后一页的模板内容
                        iText.Kernel.Pdf.Canvas.PdfCanvas addCounterCanvas = new iText.Kernel.Pdf.Canvas.PdfCanvas(currentPage.NewContentStreamAfter(), currentPage.GetResources(), document);

                        // 设置图层
                        addCounterCanvas.BeginLayer(addCounterLayer);

                        // 保存当前画布状态
                        addCounterCanvas.SaveState();

                        // 移动到居中位置
                        addCounterCanvas.ConcatMatrix(1, 0, 0, 1, centerX, centerY);

                        // 创建表单XObject来包含最后一页的内容
                        iText.Kernel.Pdf.Xobject.PdfFormXObject template = lastPage.CopyAsFormXObject(document);

                        // 绘制最后一页的内容作为模板（居中绘制）
                        addCounterCanvas.AddXObject(template);

                        // 恢复画布状态
                        addCounterCanvas.RestoreState();

                        // 结束图层
                        addCounterCanvas.EndLayer();

                        addCounterCanvas.Release();

                        // 2. 在Dots_L_B_出血线图层上绘制与页面CropBox尺寸相同的矩形
                        // 由于SetAllPageBoxesToCropBox已经统一了所有页面框，直接绘制在CropBox上即可
                        iText.Kernel.Pdf.Canvas.PdfCanvas bleedLayerCanvas = new iText.Kernel.Pdf.Canvas.PdfCanvas(currentPage.NewContentStreamAfter(), currentPage.GetResources(), document);

                        // 设置图层
                        bleedLayerCanvas.BeginLayer(bleedLayer);

                        // 创建绿色描边的笔，粗细为0.01pt
                        bleedLayerCanvas.SetLineWidth(0.01f);
                        bleedLayerCanvas.SetStrokeColor(ColorConstants.GREEN);

                        // 获取CropBox的实际坐标位置
                        iText.Kernel.Geom.Rectangle cropBox = currentPage.GetCropBox() ?? currentPage.GetMediaBox();
                        if (cropBox != null)
                        {
                            // 计算出血线的实际位置和尺寸
                            float bleedX = (float)cropBox.GetLeft();
                            float bleedY = (float)cropBox.GetBottom();
                            float bleedWidth = (float)cropBox.GetWidth();
                            float bleedHeight = (float)cropBox.GetHeight();

                            LogHelper.Debug("第" + i + "页出血线矩形: 位置=(" + bleedX + ", " + bleedY + "), 尺寸=" + bleedWidth + "x" + bleedHeight);

                            // 在CropBox的实际位置绘制出血线矩形
                            bleedLayerCanvas.Rectangle(bleedX, bleedY, bleedWidth, bleedHeight);
                            bleedLayerCanvas.Stroke();
                        }
                        else
                        {
                            // 如果无法获取CropBox，则使用默认方法绘制
                            LogHelper.Debug("第" + i + "页无法获取CropBox，使用默认绘制方法");
                            bleedLayerCanvas.Rectangle(0, 0, (float)currentPageSize.GetWidth(), (float)currentPageSize.GetHeight());
                            bleedLayerCanvas.Stroke();
                        }

                        // 结束图层
                        bleedLayerCanvas.EndLayer();

                        bleedLayerCanvas.Release();

                        // 恢复当前页面的原始旋转状态
                        currentPage.SetRotation(originalCurrentPageRotation);
                    }

                    // 恢复最后一页的原始旋转状态
                    lastPage.SetRotation(originalLastPageRotation);

                    // 删除文档的最后一页
                    document.RemovePage(lastPageIndex);
                    LogHelper.Debug("删除最后一页，剩余页数: " + document.GetNumberOfPages());

                    // 恢复除最后一页外的所有页面的原始旋转状态（因为最后一页已被删除）
                    for (int i = 1; i <= document.GetNumberOfPages(); i++)
                    {
                        document.GetPage(i).SetRotation(originalPageRotations[i - 1]);
                    }

                    LogHelper.Debug("保存修改后的文档到临时文件：" + tempFilePath);
                }
                finally
                {
                    // 确保资源被正确释放
                    document?.Close();
                    writer?.Close();
                    reader?.Close();
                }

                // 确保文件完全释放后再进行文件操作
                EnsureFileReleased(filePath);

                // 删除原始文件并将临时文件重命名为原始文件名
                if (File.Exists(filePath))
                {
                    // 直接删除原文件，不创建备份
                    try
                    {
                        File.Delete(filePath);
                        LogHelper.Debug("成功删除原文件: " + filePath);
                    }
                    catch (Exception deleteEx)
                    {
                        LogHelper.Debug("删除原文件失败: " + deleteEx.Message);
                        throw;
                    }
                }

                // 确保临时文件存在且完整
                if (File.Exists(tempFilePath) && new FileInfo(tempFilePath).Length > 0)
                {
                    File.Move(tempFilePath, filePath);
                    LogHelper.Debug("成功移动临时文件到目标位置: " + filePath);
                }
                else
                {
                    LogHelper.Debug("临时文件不存在或为空，操作取消: " + tempFilePath);
                    return false;
                }

                // 已在方法开始处调用SetAllPageBoxesToCropBox，此处不需要再调用
                LogHelper.Debug("ProcessSpecialShapePdf执行GC清理，处理完成");
                GC.Collect();
                GC.WaitForPendingFinalizers();

                return true;
            }
            catch (iText.Kernel.Exceptions.PdfException pdfEx)
            {
                LogHelper.Debug("iText 7 PDF异常: " + pdfEx.Message);
                return false;
            }
            catch (Exception ex)
            {
                LogHelper.Debug("处理异形PDF失败: " + ex.Message);
                return false;
            }
        }

        /// <summary>
        /// 使用iText7库将所有页面的MediaBox、TrimBox、BleedBox和ArtBox设置为与CropBox相同
        /// 这是避免页面内容被截断的核心方法
        /// </summary>
        /// <param name="filePath">PDF文件路径</param>
        /// <returns>是否设置成功</returns>
        public static bool SetAllPageBoxesToCropBox(string filePath)
        {
            LogHelper.Debug("SetAllPageBoxesToCropBox调用（iText7版本），文件路径: " + filePath);
            try
            {
                // 检查文件是否存在
                if (!File.Exists(filePath))
                {
                    LogHelper.Debug("文件不存在: " + filePath);
                    return false;
                }

                // 检查文件扩展名是否为PDF
                if (!SystemPath.GetExtension(filePath).Equals(".pdf", StringComparison.OrdinalIgnoreCase))
                {
                    return false;
                }

                // 创建临时文件路径
                // 使用系统临时文件夹中的PDFToolCache目录创建临时文件路径
                string tempFolder = SystemPath.Combine(SystemPath.GetTempPath(), "PDFToolCache");
                Directory.CreateDirectory(tempFolder); // 确保目录存在
                string tempFilePath = SystemPath.Combine(tempFolder, SystemPath.GetRandomFileName() + ".pdf");

                // 使用iText7处理文件
                iText.Kernel.Pdf.PdfReader reader = null;
                iText.Kernel.Pdf.PdfWriter writer = null;
                iText.Kernel.Pdf.PdfDocument document = null;

                try
                {
                    reader = new iText.Kernel.Pdf.PdfReader(filePath);
                    writer = new iText.Kernel.Pdf.PdfWriter(tempFilePath);
                    document = new iText.Kernel.Pdf.PdfDocument(reader, writer);

                // 首先分析所有页面，确定统一的基准框尺寸
                iText.Kernel.Geom.Rectangle unifiedBaseBox = null;
                var pageSizes = new List<(int page, iText.Kernel.Geom.Rectangle mediaBox, iText.Kernel.Geom.Rectangle cropBox)>();

                LogHelper.Debug("=== 第一阶段：分析所有页面尺寸 ===");
                for (int i = 1; i <= document.GetNumberOfPages(); i++)
                {
                    iText.Kernel.Pdf.PdfPage page = document.GetPage(i);
                    iText.Kernel.Geom.Rectangle mediaBox = page.GetMediaBox();
                    iText.Kernel.Geom.Rectangle cropBox = page.GetCropBox();

                    pageSizes.Add((i, mediaBox, cropBox));

                    LogHelper.Debug($"页面{i} - MediaBox: {mediaBox?.GetWidth() ?? -1}x{mediaBox?.GetHeight() ?? -1}, CropBox: {cropBox?.GetWidth() ?? -1}x{cropBox?.GetHeight() ?? -1}");
                }

                // 确定统一的基准框：优先使用最常见的有效CropBox，否则使用最常见的MediaBox
                var cropBoxGroups = pageSizes.Where(p => p.cropBox != null && p.cropBox.GetWidth() > 0 && p.cropBox.GetHeight() > 0)
                                            .GroupBy(p => $"{p.cropBox.GetWidth():F3}x{p.cropBox.GetHeight():F3}")
                                            .OrderByDescending(g => g.Count())
                                            .FirstOrDefault();

                if (cropBoxGroups != null)
                {
                    unifiedBaseBox = cropBoxGroups.First().cropBox;
                    LogHelper.Debug($"采用最常见的CropBox作为统一基准: {unifiedBaseBox.GetWidth():F3}x{unifiedBaseBox.GetHeight():F3} (出现{cropBoxGroups.Count()}次)");
                }
                else
                {
                    var mediaBoxGroups = pageSizes.Where(p => p.mediaBox != null && p.mediaBox.GetWidth() > 0 && p.mediaBox.GetHeight() > 0)
                                                .GroupBy(p => $"{p.mediaBox.GetWidth():F3}x{p.mediaBox.GetHeight():F3}")
                                                .OrderByDescending(g => g.Count())
                                                .FirstOrDefault();

                    if (mediaBoxGroups != null)
                    {
                        unifiedBaseBox = mediaBoxGroups.First().mediaBox;
                        LogHelper.Debug($"采用最常见的MediaBox作为统一基准: {unifiedBaseBox.GetWidth():F3}x{unifiedBaseBox.GetHeight():F3} (出现{mediaBoxGroups.Count()}次)");
                    }
                }

                if (unifiedBaseBox == null)
                {
                    LogHelper.Debug("无法确定统一的基准框，终止处理");
                    return false;
                }

                // 第二阶段：将所有页面的页面框设置为统一尺寸
                LogHelper.Debug("=== 第二阶段：应用统一基准框到所有页面 ===");
                for (int i = 1; i <= document.GetNumberOfPages(); i++)
                {
                    iText.Kernel.Pdf.PdfPage page = document.GetPage(i);
                    LogHelper.Debug("=== 开始处理页面，索引: " + (i - 1) + ", 页码: " + i + " ===");

                    // 获取各种页面框
                    iText.Kernel.Geom.Rectangle mediaBox = page.GetMediaBox();
                    iText.Kernel.Geom.Rectangle cropBox = page.GetCropBox();
                    iText.Kernel.Geom.Rectangle trimBox = page.GetTrimBox();
                    iText.Kernel.Geom.Rectangle bleedBox = page.GetBleedBox();
                    iText.Kernel.Geom.Rectangle artBox = page.GetArtBox();

                    // 记录原始页面框尺寸
                    LogHelper.Debug("原始页面框信息：");
                    LogHelper.Debug("- MediaBox: " + (mediaBox?.GetWidth() ?? -1) + "x" + (mediaBox?.GetHeight() ?? -1));
                    LogHelper.Debug("- CropBox: " + (cropBox?.GetWidth() ?? -1) + "x" + (cropBox?.GetHeight() ?? -1));
                    LogHelper.Debug("- TrimBox: " + (trimBox?.GetWidth() ?? -1) + "x" + (trimBox?.GetHeight() ?? -1));
                    LogHelper.Debug("- BleedBox: " + (bleedBox?.GetWidth() ?? -1) + "x" + (bleedBox?.GetHeight() ?? -1));
                    LogHelper.Debug("- ArtBox: " + (artBox?.GetWidth() ?? -1) + "x" + (artBox?.GetHeight() ?? -1));

                    LogHelper.Debug($"使用统一基准框: {unifiedBaseBox.GetWidth():F3}x{unifiedBaseBox.GetHeight():F3}");

                    // 将所有页面框设置为统一基准框 - 保持Adobe Acrobat兼容性
                    page.SetMediaBox(unifiedBaseBox);
                    page.SetCropBox(unifiedBaseBox);
                    page.SetTrimBox(unifiedBaseBox);
                    page.SetBleedBox(unifiedBaseBox);
                    page.SetArtBox(unifiedBaseBox);

                        // 记录设置后的页面框尺寸
                        LogHelper.Debug("设置后的页面框信息：");
                        LogHelper.Debug("- MediaBox: " + page.GetMediaBox().GetWidth() + "x" + page.GetMediaBox().GetHeight());
                        LogHelper.Debug("- CropBox: " + page.GetCropBox().GetWidth() + "x" + page.GetCropBox().GetHeight());
                        LogHelper.Debug("- TrimBox: " + page.GetTrimBox().GetWidth() + "x" + page.GetTrimBox().GetHeight());
                        LogHelper.Debug("- BleedBox: " + page.GetBleedBox().GetWidth() + "x" + page.GetBleedBox().GetHeight());
                        LogHelper.Debug("- ArtBox: " + page.GetArtBox().GetWidth() + "x" + page.GetArtBox().GetHeight());
                        LogHelper.Debug("=== 页面处理完成，索引: " + (i - 1) + " ===");
                    }

                    LogHelper.Debug("保存修改后的文档到临时文件：" + tempFilePath);
                }
                finally
                {
                    // 确保资源被正确释放
                    document?.Close();
                    writer?.Close();
                    reader?.Close();
                }

                // 确保文件完全释放后再进行文件操作
                EnsureFileReleased(filePath);

                // 删除原始文件并将临时文件重命名为原始文件名
                if (File.Exists(filePath))
                {
                    // 直接删除原文件，不创建备份
                    try
                    {
                        File.Delete(filePath);
                        LogHelper.Debug("成功删除原文件: " + filePath);
                    }
                    catch (Exception deleteEx)
                    {
                        LogHelper.Debug("删除原文件失败: " + deleteEx.Message);
                        throw;
                    }
                }

                // 确保临时文件存在且完整
                if (File.Exists(tempFilePath) && new FileInfo(tempFilePath).Length > 0)
                {
                    File.Move(tempFilePath, filePath);
                    LogHelper.Debug("成功移动临时文件到目标位置: " + filePath);
                }
                else
                {
                    LogHelper.Debug("临时文件不存在或为空，操作取消: " + tempFilePath);
                    return false;
                }

                return true;
            }
            catch (iText.Kernel.Exceptions.PdfException pdfEx)
            {
                LogHelper.Debug("=== iText7 PDF异常处理开始 ===");
                LogHelper.Debug("PDF异常类型: " + pdfEx.GetType().FullName);
                LogHelper.Debug("PDF异常消息: " + pdfEx.Message);
                LogHelper.Debug("处理文件: " + filePath);

                // 提供更具体的PDF异常处理建议
                if (pdfEx.Message.Contains("password") || pdfEx.Message.Contains("encrypted"))
                {
                    LogHelper.Debug("建议: PDF文件可能受密码保护，请检查文件权限");
                }
                else if (pdfEx.Message.Contains("corrupt") || pdfEx.Message.Contains("damaged"))
                {
                    LogHelper.Debug("建议: PDF文件可能已损坏，请尝试修复或重新生成文件");
                }
                else if (pdfEx.Message.Contains("header"))
                {
                    LogHelper.Debug("建议: PDF文件头可能无效，请确认文件完整性");
                }

                if (pdfEx.InnerException != null)
                {
                    LogHelper.Debug("内部异常: " + pdfEx.InnerException.Message);
                }
                LogHelper.Debug("=== iText7 PDF异常处理结束 ===");
                return false;
            }
            catch (UnauthorizedAccessException accessEx)
            {
                LogHelper.Debug("=== 文件访问权限异常 ===");
                LogHelper.Debug("权限异常: " + accessEx.Message);
                LogHelper.Debug("建议: 请检查文件权限，确保有读写权限");
                LogHelper.Debug("处理文件: " + filePath);
                LogHelper.Debug("=== 文件访问权限异常结束 ===");
                return false;
            }
            catch (IOException ioEx)
            {
                LogHelper.Debug("=== IO异常处理开始 ===");
                LogHelper.Debug("IO异常: " + ioEx.Message);
                LogHelper.Debug("建议: 文件可能被占用或磁盘空间不足");
                LogHelper.Debug("处理文件: " + filePath);
                LogHelper.Debug("=== IO异常处理结束 ===");
                return false;
            }
            catch (Exception ex)
            {
                LogHelper.Debug("=== PDF页面框处理异常开始（iText7版本） ===");
                LogHelper.Debug("异常类型: " + ex.GetType().FullName);
                LogHelper.Debug("异常消息: " + ex.Message);
                LogHelper.Debug("异常堆栈: " + ex.StackTrace);
                LogHelper.Debug("处理文件: " + filePath);
                if (ex.InnerException != null)
                {
                    LogHelper.Debug("内部异常类型: " + ex.InnerException.GetType().FullName);
                    LogHelper.Debug("内部异常消息: " + ex.InnerException.Message);
                }
                LogHelper.Debug("=== PDF页面框处理异常结束 ===");
                return false;
            }
        }

        /// <summary>
        /// 计算最终尺寸（毫米）
        /// </summary>
        /// <param name="width">原始宽度（毫米）</param>
        /// <param name="height">原始高度（毫米）</param>
        /// <param name="tetBleed">出血值（毫米）</param>
        /// <param name="cornerRadius">圆角半径</param>
        /// <param name="addPdfLayers">是否添加PDF图层</param>
        /// <returns>最终尺寸字符串</returns>
        public static string CalculateFinalDimensions(double width, double height, double tetBleed, string cornerRadius = "0", bool addPdfLayers = false)
        {
            // 应用公式: 长-tetBleed*2, 宽-tetBleed*2
            // 修正出血值计算逻辑：确保原始尺寸为PDF实际尺寸，仅减去一次双边出血值
            double finalWidth = CustomRound(width - tetBleed * 2);
            double finalHeight = CustomRound(height - tetBleed * 2);
            
            // 基础尺寸格式
            string dimensions = $"{finalWidth}x{finalHeight}";
            
            // 当addPdfLayers处于勾选状态时，根据cornerRadius添加形状信息
            if (addPdfLayers && !string.IsNullOrEmpty(cornerRadius))
            {
                string trimmedRadius = cornerRadius.Trim();
                
                // 直接从AppSettings读取形状代号配置
                var zeroShapeCode = AppSettings.Get("ZeroShapeCode") as string ?? "Z";
                var roundShapeCode = AppSettings.Get("RoundShapeCode") as string ?? "R";
                var ellipseShapeCode = AppSettings.Get("EllipseShapeCode") as string ?? "Y";
                var circleShapeCode = AppSettings.Get("CircleShapeCode") as string ?? "C";
                var hideRadiusValue = AppSettings.Get("HideRadiusValue") as bool? ?? false;
                
                // 根据形状类型添加相应代号
                if (trimmedRadius.Equals("R", StringComparison.OrdinalIgnoreCase))
                {
                    dimensions += circleShapeCode; // 使用圆形代号
                }
                else if (trimmedRadius.Equals("Y", StringComparison.OrdinalIgnoreCase))
                {
                    dimensions += ellipseShapeCode; // 使用异形代号
                }
                else if (int.TryParse(trimmedRadius, out int numRadius) && numRadius > 0)
                {
                    // 对于数字半径值，添加圆角代号
                    if (hideRadiusValue)
                    {
                        // 如果隐藏半径数值复选框被勾选，只添加代号不添加数字
                        dimensions += roundShapeCode;
                    }
                    else
                    {
                        // 否则添加代号和数字
                        dimensions += roundShapeCode + numRadius;
                    }
                }
                else if (trimmedRadius.Equals("0"))
                {
                    // 当形状输入为"0"时，添加直角代号
                    dimensions += zeroShapeCode;
                }
            }
            
            return dimensions;
        }
        
        /// <summary>
        /// 从字符串中提取数值部分（支持小数）
        /// </summary>
        /// <param name="input">输入字符串</param>
        /// <returns>提取的数值字符串</returns>
        private static string ExtractNumericValue(string input)
        {
            if (string.IsNullOrEmpty(input))
                return "0";
                
            string result = string.Empty;
            bool hasDecimalPoint = false;
            
            foreach (char c in input)
            {
                if (char.IsDigit(c))
                {
                    result += c;
                }
                else if (c == '.' && !hasDecimalPoint)
                {
                    result += c;
                    hasDecimalPoint = true;
                }
                else if (!string.IsNullOrEmpty(result))
                {
                    // 一旦遇到非数字字符且result已经有值，则停止提取
                    // 这样可以避免将形状代号（如R3）的数字部分混入
                    break;
                }
            }
            
            return string.IsNullOrEmpty(result) ? "0" : result;
        }

        /// <summary>
        /// 自定义四舍五入方法
        /// </summary>
        /// <param name="value">要四舍五入的值</param>
        /// <returns>四舍五入后的值</returns>
        private static double CustomRound(double value)
        {
            // 正常四舍五入到十分位
            return Math.Round(value, 1);
        }

        /// <summary>
        /// 获取或创建PDF图层
        /// </summary>
        /// <param name="document">PDF文档对象</param>
        /// <param name="layerName">图层名称</param>
        /// <returns>获取或创建的图层对象</returns>
        private static Spire.Pdf.Graphics.Layer.PdfLayer GetOrCreateLayer(Spire.Pdf.PdfDocument document, string layerName)
        {
            try
            {
                // 首先尝试查找现有图层
                foreach (Spire.Pdf.Graphics.Layer.PdfLayer existingLayer in document.Layers)
                {
                    if (string.Equals(existingLayer.Name, layerName, StringComparison.OrdinalIgnoreCase))
                    {
                        LogHelper.Debug($"找到现有图层: {layerName}");
                        return existingLayer;
                    }
                }

                // 如果没有找到现有图层，则创建新图层
                LogHelper.Debug($"创建新图层: {layerName}");
                return document.Layers.AddLayer(layerName);
            }
            catch (Exception ex)
            {
                LogHelper.Error($"获取或创建图层失败: {layerName}, 错误: {ex.Message}");
                // 作为fallback，尝试直接创建图层
                try
                {
                    return document.Layers.AddLayer(layerName);
                }
                catch
                {
                    LogHelper.Error($"创建fallback图层也失败: {layerName}");
                    throw;
                }
            }
        }

        /// <summary>
        /// 插入标识页（第一页之前），使用首页尺寸，居中添加文字
        /// </summary>
        /// <param name="filePath">PDF文件路径</param>
        /// <param name="textContent">要添加的文字内容（使用\n分行）</param>
        /// <param name="fontSize">字体大小（点）</param>
        /// <returns>是否成功插入</returns>
/// <summary>
        /// 添加形状图层（不进行页面统一处理，假设页面已经统一）
        /// </summary>
        /// <param name="filePath">PDF文件路径</param>
        /// <param name="finalDimensions">最终尺寸</param>
        /// <param name="shapeType">形状类型</param>
        /// <param name="roundRadius">圆角半径</param>
        /// <returns>处理是否成功</returns>
        public static bool AddDotsAddCounterLayerOnly(string filePath, string finalDimensions, ShapeType shapeType, double roundRadius = 0)
        {
            LogHelper.Debug($"AddDotsAddCounterLayerOnly调用，参数: filePath={filePath}, shapeType={shapeType}, roundRadius={roundRadius}");

            // 检查文件是否存在
            if (!File.Exists(filePath))
            {
                LogHelper.Debug("文件不存在: " + filePath);
                return false;
            }

            // 检查文件扩展名是否为PDF
            if (!SystemPath.GetExtension(filePath).Equals(".pdf", StringComparison.OrdinalIgnoreCase))
            {
                LogHelper.Debug("文件不是PDF格式: " + filePath);
                return false;
            }

            // 异形处理直接调用专用方法
            if (shapeType == ShapeType.Special)
            {
                LogHelper.Debug("检测到异形，调用ProcessSpecialShapePdf");
                return ProcessSpecialShapePdf(filePath);
            }

            string tempFilePath = null;
            try
            {
                LogHelper.Debug("开始添加形状图层（页面已统一）");

                // 创建临时文件路径
                string cacheFolder = SystemPath.Combine(SystemPath.GetTempPath(), "PDFToolCache");
                Directory.CreateDirectory(cacheFolder);
                tempFilePath = SystemPath.Combine(cacheFolder, $"temp_{Guid.NewGuid()}.pdf");

                // 复制原始文件到临时文件
                File.Copy(filePath, tempFilePath, true);

                using (Spire.Pdf.PdfDocument document = new Spire.Pdf.PdfDocument())
                {
                    document.LoadFromFile(tempFilePath);

                    // 获取或创建图层 - 实现真正的获取或创建逻辑
                    Spire.Pdf.Graphics.Layer.PdfLayer layer = GetOrCreateLayer(document, "Dots_AddCounter");
                    // 获取或创建Dots_L_B_出血线图层
                    Spire.Pdf.Graphics.Layer.PdfLayer bleedLayer = GetOrCreateLayer(document, "Dots_L_B_出血线");

                    // 解析finalDimensions参数
                    float rectWidth = 0;
                    float rectHeight = 0;
                    if (!string.IsNullOrEmpty(finalDimensions))
                    {
                        LogHelper.Debug("解析finalDimensions: " + finalDimensions);
                        string[] dimensions = finalDimensions.Split('x');
                        if (dimensions.Length == 2)
                        {
                            // 提取宽度（去掉任何非数字字符）
                            string widthStr = ExtractNumericValue(dimensions[0]);

                            // 提取高度（去掉任何非数字字符和后续的形状代号）
                            string heightStr = ExtractNumericValue(dimensions[1]);

                            LogHelper.Debug("提取的尺寸: 宽=" + widthStr + ", 高=" + heightStr);

                            // 转换毫米到点（1mm≈2.83465点）
                            if (float.TryParse(widthStr, out float widthMm) && float.TryParse(heightStr, out float heightMm))
                            {
                                float calculatedWidth = (float)(widthMm * 2.83465);
                                float calculatedHeight = (float)(heightMm * 2.83465);

                                // 获取页面方向信息（通过页面宽高比判断）- 使用iText7
                                bool isPageLandscape = false;
                                try
                                {
                                    using (iText.Kernel.Pdf.PdfReader reader = new iText.Kernel.Pdf.PdfReader(filePath))
                                    using (iText.Kernel.Pdf.PdfDocument pdfDoc = new iText.Kernel.Pdf.PdfDocument(reader))
                                    {
                                        if (pdfDoc.GetNumberOfPages() > 0)
                                        {
                                            iText.Kernel.Pdf.PdfPage pdfPage = pdfDoc.GetPage(1);
                                            iText.Kernel.Geom.Rectangle pageSize = pdfPage.GetCropBox() ?? pdfPage.GetMediaBox();
                                            if (pageSize != null)
                                            {
                                                isPageLandscape = pageSize.GetWidth() > pageSize.GetHeight();
                                                LogHelper.Debug("iText7页面方向检测成功: " + (isPageLandscape ? "横向" : "纵向"));
                                            }
                                        }
                                    }
                                }
                                catch (Exception ex)
                                {
                                    LogHelper.Debug("iText7页面方向检测失败: " + ex.Message + "，使用默认方向");
                                }

                                // 检查计算出的尺寸与页面方向是否匹配
                                bool isCalculatedLandscape = calculatedWidth > calculatedHeight;

                                // 如果页面方向和计算出的尺寸方向不一致，则交换宽度和高度
                                if (isPageLandscape != isCalculatedLandscape)
                                {
                                    rectWidth = calculatedHeight;
                                    rectHeight = calculatedWidth;
                                    LogHelper.Debug("检测到方向不匹配，交换宽度和高度: 宽=" + rectWidth + ", 高=" + rectHeight);
                                }
                                else
                                {
                                    rectWidth = calculatedWidth;
                                    rectHeight = calculatedHeight;
                                    LogHelper.Debug("转换后的尺寸(点): 宽=" + rectWidth + ", 高=" + rectHeight);
                                }
                            }
                        }
                    }

                    // 为所有页面添加图层内容
                    for (int i = 0; i < document.Pages.Count; i++)
                    {
                        Spire.Pdf.PdfPageBase page = document.Pages[i];

                        // 计算实际尺寸
                        float actualRectWidth = rectWidth;
                        float actualRectHeight = rectHeight;

                        if (actualRectWidth <= 0 || actualRectHeight <= 0)
                        {
                            LogHelper.Debug("未提供有效的finalDimensions，使用默认尺寸");
                            float minSize = 50f;
                            float maxWidthRatio = 0.8f;
                            float maxHeightRatio = 0.8f;

                            actualRectWidth = Math.Max(minSize, page.Size.Width * maxWidthRatio);
                            actualRectHeight = Math.Max(minSize, page.Size.Height * maxHeightRatio);

                            LogHelper.Debug("使用默认尺寸(点): 宽=" + actualRectWidth + ", 高=" + actualRectHeight);
                        }

                        // 计算居中位置
                        float rectX = (page.Size.Width - actualRectWidth) / 2;
                        float rectY = (page.Size.Height - actualRectHeight) / 2;

                        LogHelper.Debug($"第{i+1}页形状绘制信息: 位置=({rectX}, {rectY}), 尺寸=({actualRectWidth}x{actualRectHeight}), 形状类型={shapeType}");

                        // 创建红色描边的笔，粗细为0.01
                        Spire.Pdf.Graphics.PdfPen redPen = new Spire.Pdf.Graphics.PdfPen(System.Drawing.Color.Red, 0.01f);

                        // 获取图层的图形对象
                        Spire.Pdf.Graphics.PdfCanvas layerCanvas = layer.CreateGraphics(page.Canvas);

                        // 根据shapeType绘制不同的形状
                        switch (shapeType)
                        {
                            case ShapeType.Circle:
                                LogHelper.Debug("绘制圆形");
                                layerCanvas.DrawEllipse(redPen, rectX, rectY, actualRectWidth, actualRectHeight);
                                break;

                            case ShapeType.RoundRect:
                                LogHelper.Debug($"绘制圆角矩形，半径={roundRadius}毫米");
                                float cornerRadiusPt = (float)(roundRadius * 2.83465); // 转换毫米到点

                                // 使用PdfPath手动创建圆角矩形
                                Spire.Pdf.Graphics.PdfPath path = new Spire.Pdf.Graphics.PdfPath();

                                // 确保圆角半径不会太大
                                float radiusPt = Math.Min(cornerRadiusPt, Math.Min(actualRectWidth, actualRectHeight) / 2);

                                LogHelper.Debug($"圆角半径计算: 原始={cornerRadiusPt}点, 限制到={radiusPt}点");

                                // 绘制圆角矩形的各个角和边
                                path.AddArc(rectX + actualRectWidth - 2 * radiusPt, rectY, 2 * radiusPt, 2 * radiusPt, 270, 90);
                                path.AddLine(rectX + actualRectWidth, rectY + radiusPt, rectX + actualRectWidth, rectY + actualRectHeight - radiusPt);
                                path.AddArc(rectX + actualRectWidth - 2 * radiusPt, rectY + actualRectHeight - 2 * radiusPt, 2 * radiusPt, 2 * radiusPt, 0, 90);
                                path.AddLine(rectX + actualRectWidth - radiusPt, rectY + actualRectHeight, rectX + radiusPt, rectY + actualRectHeight);
                                path.AddArc(rectX, rectY + actualRectHeight - 2 * radiusPt, 2 * radiusPt, 2 * radiusPt, 90, 90);
                                path.AddLine(rectX, rectY + actualRectHeight - radiusPt, rectX, rectY + radiusPt);
                                path.AddArc(rectX, rectY, 2 * radiusPt, 2 * radiusPt, 180, 90);
                                path.AddLine(rectX + radiusPt, rectY, rectX + actualRectWidth - radiusPt, rectY);

                                path.CloseAllFigures();
                                layerCanvas.DrawPath(redPen, path);
                                break;

                            case ShapeType.RightAngle:
                            default:
                                LogHelper.Debug("绘制直角矩形");
                                layerCanvas.DrawRectangle(redPen, rectX, rectY, actualRectWidth, actualRectHeight);
                                break;
                        }

                        // 在Dots_L_B_出血线图层上绘制绿色居中矩形
                        float bleedRectX = 0;
                        float bleedRectY = 0;
                        float bleedRectWidth = page.Size.Width;
                        float bleedRectHeight = page.Size.Height;

                        Spire.Pdf.Graphics.PdfPen greenPen = new Spire.Pdf.Graphics.PdfPen(System.Drawing.Color.Green, 0.01f);
                        Spire.Pdf.Graphics.PdfCanvas bleedLayerCanvas = bleedLayer.CreateGraphics(page.Canvas);
                        bleedLayerCanvas.DrawRectangle(greenPen, bleedRectX, bleedRectY, bleedRectWidth, bleedRectHeight);
                    }

                    // 保存修改后的PDF文件
                    document.SaveToFile(tempFilePath);
                    document.Close();

                    // 确保文件完全释放后再进行文件操作
                    EnsureFileReleased(filePath);

                    // 验证临时文件完整性
                    if (!File.Exists(tempFilePath) || new FileInfo(tempFilePath).Length == 0)
                    {
                        LogHelper.Debug("临时文件生成失败或为空: " + tempFilePath);
                        return false;
                    }

                    // 删除原始文件并将临时文件重命名为原始文件名
                    if (File.Exists(filePath))
                    {
                        // 直接删除原文件，不创建备份（用户只需要导出路径有一个结果文件）
                        try
                        {
                            File.Delete(filePath);
                            LogHelper.Debug("成功删除原文件: " + filePath);
                        }
                        catch (Exception deleteEx)
                        {
                            LogHelper.Debug("删除原文件失败: " + deleteEx.Message);
                            // 如果删除失败，直接抛出异常，不创建备份
                            throw;
                        }
                    }

                    // 确保临时文件存在且完整
                    if (File.Exists(tempFilePath) && new FileInfo(tempFilePath).Length > 0)
                    {
                        File.Move(tempFilePath, filePath);
                        LogHelper.Debug("成功移动临时文件到目标位置: " + filePath);
                    }
                    else
                    {
                        LogHelper.Debug("临时文件不存在或为空，操作取消: " + tempFilePath);
                        return false;
                    }

                    // 验证最终文件操作成功
                    if (!File.Exists(filePath) || new FileInfo(filePath).Length == 0)
                    {
                        LogHelper.Debug("最终文件操作失败: " + filePath);
                        return false;
                    }

                    LogHelper.Debug("AddDotsAddCounterLayerOnly完成");
                    return true;
                }
            }
            catch (Exception ex)
            {
                LogHelper.Debug("添加图层失败: " + ex.Message);
                return false;
            }
            finally
            {
                // 确保清理临时文件
                if (tempFilePath != null && File.Exists(tempFilePath))
                {
                    try
                    {
                        File.Delete(tempFilePath);
                    }
                    catch (Exception ex)
                    {
                        LogHelper.Debug("清理临时文件失败: " + ex.Message);
                    }
                }
            }
        }


        public static bool InsertIdentifierPage(string filePath, string textContent, float fontSize = 12f)
        {
            try
            {
                if (!File.Exists(filePath))
                {
                    LogHelper.Error($"文件不存在: {filePath}");
                    return false;
                }
                
                if (!SystemPath.GetExtension(filePath).Equals(".pdf", StringComparison.OrdinalIgnoreCase))
                {
                    LogHelper.Error($"不是PDF文件: {filePath}");
                    return false;
                }
                
                // 即使内容为空也要插入空白页
                LogHelper.Debug("开始插入标识页（内容可以为空）");
                
                using (Spire.Pdf.PdfDocument document = new Spire.Pdf.PdfDocument())
                {
                    document.LoadFromFile(filePath);
                    
                    if (document.Pages.Count == 0)
                    {
                        LogHelper.Error("文档没有页面");
                        return false;
                    }
                    
                    // 获取首页尺寸和旋转信息
                    Spire.Pdf.PdfPageBase firstPage = document.Pages[0];
                    float pageWidth = firstPage.Size.Width;
                    float pageHeight = firstPage.Size.Height;
                    Spire.Pdf.PdfPageRotateAngle rotation = firstPage.Rotation;

                    LogHelper.Debug($"首页尺寸: {pageWidth}x{pageHeight} 点, 旋转角度: {rotation}");

                    // 在第一页之前插入新页，应用相同的旋转
                    Spire.Pdf.PdfPageBase newPage = document.Pages.Insert(0, new SizeF(pageWidth, pageHeight));
                    newPage.Rotation = rotation;
                    
                    LogHelper.Debug($"创建新标识页，应用旋转角度: {rotation}");
                    
                    // 定义字体（使用黑体以支持中文）
                    Spire.Pdf.Graphics.PdfFont font = new Spire.Pdf.Graphics.PdfFont(
                        Spire.Pdf.Graphics.PdfFontFamily.Helvetica, 
                        fontSize,
                        Spire.Pdf.Graphics.PdfFontStyle.Regular
                    );
                    
                    Spire.Pdf.Graphics.PdfBrush brush = Spire.Pdf.Graphics.PdfBrushes.Black;
                    
// 只有当内容不为空时才绘制文字                    if (!string.IsNullOrWhiteSpace(textContent))                    {                        DrawCenteredTextWithWordWrap(newPage, textContent, font, brush, pageWidth, pageHeight, fontSize);                    }                    else                    {                        LogHelper.Debug("标识页内容为空，创建空白页");                    }
                    
                    // 保存文件
                    string tempFolder = SystemPath.Combine(SystemPath.GetTempPath(), "PDFToolCache");
                    Directory.CreateDirectory(tempFolder);
                    string tempFilePath = SystemPath.Combine(tempFolder, $"temp_{Guid.NewGuid()}.pdf");
                    
                    document.SaveToFile(tempFilePath);
                    document.Close();

                    // 确保文件完全释放后再进行文件操作
                    EnsureFileReleased(filePath);

                    // 删除原始文件并将临时文件重命名为原始文件名
                    if (File.Exists(filePath))
                    {
                        // 直接删除原文件，不创建备份（用户只需要导出路径有一个结果文件）
                        try
                        {
                            File.Delete(filePath);
                            LogHelper.Debug("成功删除原文件: " + filePath);
                        }
                        catch (Exception deleteEx)
                        {
                            LogHelper.Debug("删除原文件失败: " + deleteEx.Message);
                            // 如果删除失败，直接抛出异常，不创建备份
                            throw;
                        }
                    }

                    // 确保临时文件存在且完整
                    if (File.Exists(tempFilePath) && new FileInfo(tempFilePath).Length > 0)
                    {
                        File.Move(tempFilePath, filePath);
                        LogHelper.Debug("成功移动临时文件到目标位置: " + filePath);
                    }
                    else
                    {
                        LogHelper.Debug("临时文件不存在或为空，操作取消: " + tempFilePath);
                        return false;
                    }

                    LogHelper.Debug($"成功插入标识页: {filePath}");
                    return true;
                }
            }
            catch (Exception ex)
            {
                LogHelper.Error($"插入标识页失败: {ex.Message}", ex);
                return false;
            }
        }

/// <summary>
        /// 在PDF页面上绘制居中的文字，支持自动换行
        /// </summary>
        /// <param name="page">PDF页面</param>
        /// <param name="text">要绘制的文字</param>
        /// <param name="font">字体</param>
        /// <param name="brush">画刷</param>
        /// <param name="pageWidth">页面宽度</param>
        /// <param name="pageHeight">页面高度</param>
        /// <param name="fontSize">字体大小</param>
        private static void DrawCenteredTextWithWordWrap(Spire.Pdf.PdfPageBase page, string text, Spire.Pdf.Graphics.PdfFont font, Spire.Pdf.Graphics.PdfBrush brush, float pageWidth, float pageHeight, float fontSize)
        {
            try
            {
                // 设置页边距
                float margin = fontSize * 2; // 边距为字体大小的2倍
                float maxWidth = pageWidth - (margin * 2);
                float lineHeight = fontSize * 1.5f; // 行高 = 字体大小 * 1.5
                
                // 将文字按分隔符分割成多个部分
                string[] parts = text.Split(new[] { "_", "-", " ", "：", ":", "，", ",", "、", "。" }, StringSplitOptions.RemoveEmptyEntries);
                
                // 逐行构建文字，支持自动换行
                List<string> lines = new List<string>();
                string currentLine = "";
                
                foreach (string part in parts)
                {
                    string testLine = string.IsNullOrEmpty(currentLine) ? part : currentLine + "_" + part;
                    SizeF textSize = font.MeasureString(testLine);
                    
                    if (textSize.Width <= maxWidth)
                    {
                        // 当前行可以容纳这个部分
                        currentLine = testLine;
                    }
                    else
                    {
                        // 当前行无法容纳，需要换行
                        if (!string.IsNullOrEmpty(currentLine))
                        {
                            lines.Add(currentLine);
                        }
                        
                        // 检查单个部分是否超过最大宽度
                        SizeF partSize = font.MeasureString(part);
                        if (partSize.Width > maxWidth)
                        {
                            // 如果单个部分太长，强制拆分
                            string remainingPart = part;
                            while (!string.IsNullOrEmpty(remainingPart))
                            {
                                string fitLine = "";
                                for (int i = 1; i <= remainingPart.Length; i++)
                                {
                                    string testFit = remainingPart.Substring(0, i);
                                    SizeF fitSize = font.MeasureString(testFit);
                                    if (fitSize.Width <= maxWidth)
                                    {
                                        fitLine = testFit;
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }
                                
                                if (string.IsNullOrEmpty(fitLine))
                                {
                                    // 连一个字符都放不下，强制添加一个字符
                                    fitLine = remainingPart.Substring(0, 1);
                                    lines.Add(fitLine);
                                    remainingPart = remainingPart.Substring(1);
                                }
                                else
                                {
                                    lines.Add(fitLine);
                                    remainingPart = remainingPart.Substring(fitLine.Length);
                                }
                            }
                            currentLine = "";
                        }
                        else
                        {
                            // 单个部分可以放下，作为新行的开始
                            currentLine = part;
                        }
                    }
                }
                
                // 添加最后一行
                if (!string.IsNullOrEmpty(currentLine))
                {
                    lines.Add(currentLine);
                }
                
                // 如果没有有效行，创建一个空行
                if (lines.Count == 0)
                {
                    lines.Add(" ");
                }
                
                // 计算总高度
                float totalHeight = lines.Count * lineHeight;
                
                // 计算起始Y坐标（垂直居中）
                float startY = (pageHeight - totalHeight) / 2;
                
                // 确保起始位置不超出页面边界
                if (startY < margin)
                {
                    startY = margin;
                }
                
                // 绘制每行文字
                for (int i = 0; i < lines.Count; i++)
                {
                    string line = lines[i].Trim();
                    if (string.IsNullOrEmpty(line))
                        continue;
                    
                    // 测量文字宽度
                    SizeF textSize = font.MeasureString(line);
                    
                    // 计算X坐标（水平居中）
                    float x = (pageWidth - textSize.Width) / 2;
                    float y = startY + (i * lineHeight);
                    
                    // 绘制文字
                    page.Canvas.DrawString(line, font, brush, x, y);
                    
                    LogHelper.Debug($"绘制标识页文字第{i+1}行: '{line}' 位置=({x:F2}, {y:F2})");
                }
                
                LogHelper.Debug($"标识页文字绘制完成，共{lines.Count}行");
            }
            catch (Exception ex)
            {
                LogHelper.Error($"绘制居中文字失败: {ex.Message}", ex);
                // 发生错误时，使用简单的居中绘制
                try
                {
                    SizeF textSize = font.MeasureString(text);
                    float x = (pageWidth - textSize.Width) / 2;
                    float y = pageHeight / 2;
                    page.Canvas.DrawString(text, font, brush, x, y);
                    LogHelper.Debug($"使用简单居中绘制: '{text}' 位置=({x:F2}, {y:F2})");
                }
                catch (Exception simpleEx)
                {
                    LogHelper.Error($"简单居中绘制也失败: {simpleEx.Message}", simpleEx);
                }
            }
        }
    }
}